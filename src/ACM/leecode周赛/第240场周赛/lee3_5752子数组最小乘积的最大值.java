package ACM.leecode周赛.第240场周赛;

public class lee3_5752子数组最小乘积的最大值 {
    /***
     一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。

     比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。
     给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。

     请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。
     子数组 定义为一个数组的 连续 部分。
     示例 1：
     输入：nums = [1,2,3,2]
     输出：14
     解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
     2 * (2+3+2) = 2 * 7 = 14 。
     */
    public static void main(String[] args) {
        System.out.println(maxSumMinProduct2(new int[]{1, 2, 3, 2}));
        System.out.println(maxSumMinProduct2(new int[]{2, 3, 3, 1, 2}));
        System.out.println(maxSumMinProduct2(new int[]{3, 1, 5, 6, 4, 2}));
        System.out.println(maxSumMinProduct2(new int[]{18, 69, 23, 33, 48, 46, 9, 65, 2, 81, 60, 15, 8, 85, 55, 30, 72, 78,
                79, 31, 80, 25, 77, 63, 100, 68, 95, 71, 67, 97, 40, 6, 61, 1, 24, 42, 91, 32, 52, 37, 26, 59, 83, 16, 20,
                19, 43, 17, 35, 51, 47, 36, 92, 27, 89, 76, 98, 7, 66, 11, 28, 99, 39, 73, 56, 4, 88, 87, 12, 75, 86, 90,
                96, 44, 82, 14, 34, 41, 3, 38, 5, 10, 58, 21, 29, 84, 74, 62, 13, 93, 70, 45, 49, 64, 53, 22, 54, 94, 57,
                50, 10000000, 9999999, 9999998, 9999997, 9999996, 9999995, 9999994, 9999993, 9999992, 9999991, 9999990, 9999989,
                9999988, 9999987, 9999986, 9999985, 9999984, 9999983, 9999982, 9999981, 9999980, 9999979, 9999978, 9999977,
                9999976, 9999975, 9999974, 9999973, 9999972, 9999971, 9999970, 9999969, 9999968, 9999967, 9999966, 9999965,
                9999964, 9999963, 9999962, 9999961, 9999960, 9999959, 9999958, 9999957, 9999956, 9999955, 9999954, 9999953,
                9999952, 9999951, 9999950, 9999949, 9999948, 9999947, 9999946, 9999945, 9999944, 9999943, 9999942, 9999941,
                9999940, 9999939, 9999938, 9999937, 9999936, 9999935, 9999934, 9999933, 9999932, 9999931, 9999930, 9999929,
                9999928, 9999927, 9999926, 9999925, 9999924, 9999923, 9999922, 9999921, 9999920, 9999919, 9999918, 9999917,
                9999916, 9999915, 9999914, 9999913, 9999912, 9999911, 9999910, 9999909, 9999908, 9999907, 9999906, 9999905,
                9999904, 9999903, 9999902, 9999901, 9999900, 9999899, 9999898, 9999897, 9999896, 9999895, 9999894, 9999893,
                9999892, 9999891, 9999890, 9999889, 9999888, 9999887, 9999886, 9999885, 9999884, 9999883, 9999882, 9999881,
                9999880, 9999879, 9999878, 9999877, 9999876, 9999875, 9999874, 9999873, 9999872, 9999871, 9999870, 9999869,
                9999868, 9999867, 9999866, 9999865, 9999864, 9999863, 9999862, 9999861, 9999860, 9999859, 9999858, 9999857,
                9999856, 9999855, 9999854, 9999853, 9999852, 9999851, 9999850, 9999849, 9999848, 9999847, 9999846, 9999845,
                9999844, 9999843, 9999842, 9999841, 9999840, 9999839, 9999838, 9999837, 9999836, 9999835, 9999834, 9999833,
                9999832, 9999831, 9999830, 9999829, 9999828, 9999827, 9999826, 9999825, 9999824, 9999823, 9999822, 9999821,
                9999820, 9999819, 9999818, 9999817, 9999816, 9999815, 9999814, 9999813, 9999812, 9999811, 9999810, 9999809}));
    }

    //方法一:暴力解法,枚举所有子数组 24
    public static int maxSumMinProduct(int[] nums) {

        long max = 0;
        for (int i = 0; i < nums.length; i++) {
            //从0开始能形成的子数组连续
            int sum = 0;
            int min = nums[i];
            for (int j = i; j < nums.length; j++) {
                sum += nums[j];
                min = Math.min(min, nums[j]);
                max = Math.max(max, min * sum);
            }

        }
        return (int) ((int) max % (Math.pow(10, 9) + 7));
    }

    //方法二:中心辐射法,假如最小值是num[i]的话,两边大于等于我的都是sum 28
    public static int maxSumMinProduct2(int[] nums) {

        long max = 0;
        for (int i = 0; i < nums.length; i++) {
            //假如最小值是i
            int min = nums[i];
            int sum = nums[i];
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] < min) {
                    break;
                }
                sum += nums[j];
            }
            for (int j = i - 1; j >= 0; j--) {
                if (nums[j] < min) {
                    break;
                }
                sum += nums[j];
            }
            long tempmax = sum * min;
            if (tempmax > max) {
                max = tempmax;
            }

        }
        return (int) (max % (int) (Math.pow(10, 9) + 7));
    }

    //方法三:单调栈
    public static int maxSumMinProduct3(int[] nums) {

        return 0;
    }
}
